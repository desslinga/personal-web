<div class="blog">
  <div class="row">
    <div class="col-12">
      <h3>Questions 21-30</h3>
    </div>
    <div class="col-12">
      <h3>
        31. Loop 100 times, and print "fizz" at multiples of <code>3</code>,
        "buzz" at multiple of <code>5</code>, and "fizzbuzz" at multiples of
        <code>3</code> and <code>5</code>.
      </h3>
      <pre class="language-javascript"><code>// using simple for loop
for (let i = 1; i &lt;= 100; i++) &#123;
  let f = i % 3 === 0, b = i % 5 === 0;
  if (f && b) console.log("FizzBuzz");
  else if (f) console.log("Fizz");
  else if (b) console.log("Buzz");
&#125;</code></pre>
      <hr>
      <h3>
        32. Why is it, in general, a good idea to leave the <defn>global scope
        </defn> of a website as-is, and never touch it?
      </h3>
      <p>
        Every script has access to the <defn>global scope</defn>. If any of
        the variables there are modified, then the multiple scrips that rely
        on them, may not work as expected. In order to avoid these collissions,
        variables should be <defn>encapsulated</defn> to a local namespace
        (<defn>IIFE</defn>s can be used for this.)
      </p>
      <hr>
      <h3>
        33. Why would you use the <code>load</code> event? Does this event have
        disadvantages? Do you know any alternatives?
      </h3>
      <p>
        The window <code>load</code> event fires when both the HTML document
        has <defn>finished parsing</defn>, and its <defn>resources</defn> have
        <defn>downloaded</defn>. It is ideal to use <code>load</code> when
        executing a function that needs the HTML document as well as its
        resources all ready. The disadvantage is that this approach may take
        longer than necessary.
      </p>
      <p>
        An alternative is using the <code>DOMContentLoaded</code> event, which
        fires when the HTML document has <defn>finished parsing</defn>. It
        <defn>doesn't wait</defn> for its resources to finish downloading.
        Thus, it is ideal to use <code>DOMContentLoaded</code> when executing
        a function that only needs the HTML document to have finished (not
        necessarily with its resources.)
      </p>
      <hr>
      <h3>
        34. Explain what a <defn>single page app</defn> is and how to make one
        <defn>SEO-friendly</defn>.
      </h3>
      <p>
        Traditionally (earlier days of web-app development), the browser
        recieves complete HTML from the server. The browser's only job is to
        <defn>render</defn> that HTML page. When a user navigates to another
        url, then a <defn>page refresh</defn> is required, fetching a new
        HTML page to be re-rendered. This is called <defn>server-side rendering
        </defn>.
      </p>
      <p>
        When we have <defn>page refreshes</defn>, we don't consider that web-app
        as a <defn>single page app</defn>. For <defn>SPA</defn>s, we use
        <defn>client-side rendering</defn>.
      </p>
      <p>
        <defn>Client-side rendering</defn>: browser loads the initial page, and
        <defn>downloads</defn> all its <defn>scripts and resources</defn>
        (frameworks, libraries, stylesheets).
      </p>
      <p>
        Whenever new content is to be displayed on the page, we <defn>don't
        </defn> perform a page refresh. Instead, we use the <defn>History API
        </defn>, and new data is retrieved from the server via
        <defn>AJAX</defn>. It is the job of the browser to process and render
        data from the server, and <defn>dynamically</defn> update the page.
      </p>
      <p>Advantages:</p>
      <ul>
        <li><p>
          App feels <defn>responsive</defn> and has a smoother experience.
        </p></li>
        <li><p>
          <defn>Fewer HTTP requests</defn>, because scripts and other resources
          don't have to be re-downloaded on every page refresh.
        </p></li>
        <li><p>
          <defn>Separation</defn> between <defn>client</defn> and
          <defn>server</defn>, allowing each to have separate code-bases, and
          responsibilites.
        </p></li>
      </ul>
      <p>Disadvantages:</p>
      <ul>
        <li><p>
          <defn>Heavier initial page load</defn> because scripts and resources
          required for future pages are also downloaded.
        </p></li>
        <li><p>
          Requirement to <defn>configure routes</defn> to a single entry point
          because all routing requests are to be handled by the client.
        </p></li>
        <li><p>
          <defn>Reliance on JavaScript</defn>, because some search engines
          don't enable JavaScript during <defn>web-crawling</defn>. This
          will hurt the <defn>SEO</defn> of a page. As a work-around, we can
          use services that "pre-render" a static version of the site, to be
          given to web-crawlers.
        </p></li>
      </ul>
      <hr>
      <h3>
        35. What is a <defn>Promise</defn>?
      </h3>
      <p>
        <defn>Promise</defn>: an object that may return a <defn>single value
        </defn> sometime in the future. At any time, a <defn>promise</defn>
        is in one of three states:
      </p>
      <ul>
        <li><p>
          <defn>Fulfilled:</defn> the <defn>promise</defn> has <defn>resolved
          </defn> to a single, succesful (implied) value.
        </p></li>
        <li><p>
          <defn>Rejected:</defn> the <defn>promise</defn> has <defn>resolved
          </defn> to a single, failed (implied) value.
        </p></li>
        <li><p>
          <defn>Pending:</defn> the <defn>promise</defn> has not yet been
          <defn>resolved</defn> (by being <defn>fulfilled</defn> or <defn>
          rejected</defn>.)
        </p></li>
      </ul>
      <p>
        We say that a <defn>promise</defn> is <defn>settled (resolved)</defn>
        if it is <defn>not pending</defn>. Once a <defn>promise</defn> has been
        <defn>settled</defn>, then it cannot be resettled again.
      </p>
      <p>
        When using a <defn>promise</defn>, one can use a <defn>callback</defn>
        to handle the fulfilled value (or rejected reason).
      </p>
      <hr>
      <h3>
        36. What are the pros and cons of using <defn>Promises</defn> instead of
        <defn>callbacks</defn>?
      </h3>
      <p>Pros:</p>
      <ul>
        <li><p>
          Avoiding <defn>callback hell</defn> (unreadable code).
        </p></li>
        <li><p>
          Can <defn>chain sequential asynchronous</defn> code by using the
          <code class="language-javascript">.then()</code>.
        </p></li>
        <li><p>
          For <defn>parallel asynchronous</defn> code, we can use
          <code class="language-javascript">Promise.all()</code>.
        </p></li>
        <li>
          <p>
          The following issues, which happen with callbacks, won't happen:
          </p>
          <ul>
            <li><p>
              Avoiding <defn>callback hell</defn> (unreadable code).
            </p></li>
            <li><p>
              Callback being called <defn>too early</defn>.
            </p></li>
            <li><p>
              Callback being called <defn>too late</defn> (or <defn>never
              </defn>.)
            </p></li>
            <li><p>
              Callback being called <defn>too few</defn> or <defn>too many
              </defn> times.
            </p></li>
            <li><p>
              <defn>Environments/parameters</defn> that the callback needs may
              not be passed to the callback.
            </p></li>
            <li><p>
              <defn>Errors/exceptions</defn> may be swallowed by callback
              (not reported.)
            </p></li>
          </ul>
        </li>
      </ul>
      <p>Cons:</p>
      <ul>
        <li><p>
          Code is slightly more <defn>complex</defn>.
        </p></li>
        <li><p>
          Older browsers may <defn>not support ES2015</defn> so a <defn>
          polyfill</defn> would be required.
        </p></li>
      </ul>
    </div>
  </div>
</div>
