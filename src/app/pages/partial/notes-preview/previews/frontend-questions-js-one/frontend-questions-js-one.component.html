<div class="blog">
  <div class="row">
    <div class="col-12">
      <h3>Questions 1-10</h3>
    </div>
    <div class="col-12">
      <h3>
        1. Explain <defn>event delegation</defn>.
      </h3>
      <p>
        This is a technique that involves putting one <defn>event handler</defn>
        to a parent element, to prevent having to add multiple
        <defn>event handlers</defn> to child elements. For example, if we have
        a list container, containing multiple list elements, and want to do
        something on a <defn>click</defn> event, we can put one <defn>event
        handler</defn> on the list container.
      </p>
      <p>
        Since there is <defn>event delegation</defn>, when any one of the list
        elements are clicked, that event <defn>bubbles</defn> up to some
        parent container where it is handled by an <defn>event handler</defn>.
      </p>
      <p>Benefits:</p>
      <ul>
        <li><p>
          <defn>Cleaner</defn>, more <defn>efficient</defn> because one handler
          on a parent element can handle events evoked for any of its children.
        </p></li>
        <li><p>
          No need to <defn>unbind</defn> handler when elements are removed (and
          otherwise when new elements are introduced).
        </p></li>
      </ul>
      <hr>
      <h3>
        2. Explain how <code>this</code> works in JavaScript.
      </h3>
      <p>
        Put simply: the value of <code>this</code> is determined by which
        function calls it (the <defn>call site</defn>), and where the function
        is called.
      </p>
      <p>The rules:</p>
      <ol>
        <li>
          <p>
            If the function containing <code>this</code> is called with the
            <code>new</code> keyword, the <code>this</code> inside the function
            references a new object.
          </p>
          <pre class="language-javascript"><code>function Example() &#123;
  console.log(this);
  this.value = 10;
  console.log(this);
&#125;
new Example();
// prints &#123;&#125;
// prints &#123; value: 10 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called with
            <code>.apply()</code>, <code>.call()</code> or <code>.bind()</code>,
            then <code>this</code> inside the function references the object
            passed as an argument.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
var obj = &#123; value: 5 &#125;
var boundFn = fn.bind(obj);
boundFn(); // &#123; value: 5 &#125;
fn.call(obj); // &#123; value: 5 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>method</defn>, then <code>this</code> inside the function
            refereces the object that the <defn>method</defn> belongs to.
          </p>
          <pre class="language-javascript"><code>var obj = &#123;
  value: 5,
  print: function() &#123;
   console.log(this);
  &#125;
&#125;
obj.print(); // &#123; value:5, print: f &#125; (this is obj)</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>free function invocation</defn> (read: not matching any of
            the first 3 conditions), then <code>this</code> inside the function
            is the <defn>global object</defn>. For a browser, this is
            <code>window</code>.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
// if it was called in the browser:
fn(); // Window &#123; stop: f, open: f ... &#125;</code></pre>
        </li>
        <li><p>
          If <defn>multiple</defn> of the above rules apply, the
          <defn>higher</defn> one wins (and sets the definition of
          <code>this</code>).
        </p></li>
        <li>
          <p>
            If function containing <code>this</code> is an <defn>arrow function
            </defn>, then all the above rules are ignored. <code>this</code>
            inside the function is the immediate <defn>scope</defn> outside
            where the function is declared.
          </p>
          <pre class="language-javascript"><code>const obj = &#123;
  value: 'hello',
  fn: () =&gt; console.log(this);
&#125;
obj.fn(); // &#123; value: 'hello', fn: f &#125;</code></pre>
        </li>
      </ol>
      <hr>
      <h3>
        3. Explain how <defn>prototypal inheritance</defn> works.
      </h3>
      <p>
        All JavaScript objects have a <defn>prototype</defn> property, which is
        a reference to another object (which is its <defn>'parent'</defn>).
        When we try to access an object's property, and that property isn't
        defined in the object, then the JavaScript engine goes to that object's
        <defn>prototype</defn>. It looks for the property there, and so on
        (until the property is found).
      </p>
      <p>
        Note that this looks like <defn>classical inheritance</defn>, but
        actually behaves differently. We can say that this is simply
        <defn>behaviour delegation</defn>. Properties/,ethods don't get
        'passed' onto children, rather, the <defn>responsibility</defn> for
        properties/methods that aren't found in children, are 'passed' onto
        their parent (<defn>prototype</defn>).
      </p>
      <p>
        In <defn>classical inheritance</defn>, we do have properties/methods
        passed onto children in <defn>compile time</defn>. The <defn>
        inheritance chain</defn> of a class instance (consisting of inherited
        properties/methods) is <defn>flattened</defn> into the instance class.
        (in combination with lookup tables for super functions).
      </p>
      <hr>
      <h3>
        4. <defn>AMD</defn> vs <defn>CommonJS</defn>?
      </h3>
      <p>
        These are both ways to implement a <defn>module system</defn>, which was
        not a feature native in <defn>JavaScript</defn> until
        <defn>ES6/2015</defn>.
      </p>
      <p>
        <defn>CommonJS</defn>: synchronous, and designed for server-side
        development. Syntax is simpler and is closer to
        <defn>Node</defn>. There is less overhead caused by
        <defn>context-switching</defn> between client and server-side JS
        development.
      </p>
      <p>
        <defn>AMD</defn>: a.k.a <defn>Asynchronous Module Definition</defn>
        (read: asynchronous), more intended for browsers. Syntax is much more
        verbose, and often unnecessary because JavaScript files are usually
        bundled, thus not benefiting from asynchronous loading.
      </p>
    </div>
  </div>
</div>
