<div class="blog">
  <div class="row">
    <div class="col-12">
      <h3>Questions 1-10</h3>
    </div>
    <div class="col-12">
      <h3>
        1. Explain <defn>event delegation</defn>.
      </h3>
      <p>
        This is a technique that involves putting one <defn>event handler</defn>
        to a parent element, to prevent having to add multiple
        <defn>event handlers</defn> to child elements. For example, if we have
        a list container, containing multiple list elements, and want to do
        something on a <defn>click</defn> event, we can put one <defn>event
        handler</defn> on the list container.
      </p>
      <p>
        Since there is <defn>event delegation</defn>, when any one of the list
        elements are clicked, that event <defn>bubbles</defn> up to some
        parent container where it is handled by an <defn>event handler</defn>.
      </p>
      <p>Benefits:</p>
      <ul>
        <li><p>
          <defn>Cleaner</defn>, more <defn>efficient</defn> because one handler
          on a parent element can handle events evoked for any of its children.
        </p></li>
        <li><p>
          No need to <defn>unbind</defn> handler when elements are removed (and
          otherwise when new elements are introduced).
        </p></li>
      </ul>
      <hr>
      <h3>
        2. Explain how <code>this</code> works in JavaScript.
      </h3>
      <p>
        Put simply: the value of <code>this</code> is determined by which
        function calls it (the <defn>call site</defn>), and where the function
        is called.
      </p>
      <p>The rules:</p>
      <ol>
        <li>
          <p>
            If the function containing <code>this</code> is called with the
            <code>new</code> keyword, the <code>this</code> inside the function
            references a new object.
          </p>
          <pre class="language-javascript"><code>function Example() &#123;
  console.log(this);
  this.value = 10;
  console.log(this);
&#125;
new Example();
// prints &#123;&#125;
// prints &#123; value: 10 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called with
            <code>.apply()</code>, <code>.call()</code> or <code>.bind()</code>,
            then <code>this</code> inside the function references the object
            passed as an argument.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
var obj = &#123; value: 5 &#125;
var boundFn = fn.bind(obj);
boundFn(); // &#123; value: 5 &#125;
fn.call(obj); // &#123; value: 5 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>method</defn>, then <code>this</code> inside the function
            refereces the object that the <defn>method</defn> belongs to.
          </p>
          <pre class="language-javascript"><code>var obj = &#123;
  value: 5,
  print: function() &#123;
   console.log(this);
  &#125;
&#125;
obj.print(); // &#123; value:5, print: f &#125; (this is obj)</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>free function invocation</defn> (read: not matching any of
            the first 3 conditions), then <code>this</code> inside the function
            is the <defn>global object</defn>. For a browser, this is
            <code>window</code>.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
// if it was called in the browser:
fn(); // Window &#123; stop: f, open: f ... &#125;</code></pre>
        </li>
        <li><p>
          If <defn>multiple</defn> of the above rules apply, the
          <defn>higher</defn> one wins (and sets the definition of
          <code>this</code>).
        </p></li>
        <li>
          <p>
            If function containing <code>this</code> is an <defn>arrow function
            </defn>, then all the above rules are ignored. <code>this</code>
            inside the function is the immediate <defn>scope</defn> outside
            where the function is declared.
          </p>
          <pre class="language-javascript"><code>const obj = &#123;
  value: 'hello',
  fn: () =&gt; console.log(this);
&#125;
obj.fn(); // &#123; value: 'hello', fn: f &#125;</code></pre>
        </li>
      </ol>
    </div>
  </div>
</div>
