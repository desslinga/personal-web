<div class="blog">
  <div class="row">
    <div class="col-12">
      <h3>Questions 1-10</h3>
    </div>
    <div class="col-12">
      <h3>
        1. Explain <defn>event delegation</defn>.
      </h3>
      <p>
        This is a technique that involves putting one <defn>event handler</defn>
        to a parent element, to prevent having to add multiple
        <defn>event handlers</defn> to child elements. For example, if we have
        a list container, containing multiple list elements, and want to do
        something on a <defn>click</defn> event, we can put one <defn>event
        handler</defn> on the list container.
      </p>
      <p>
        Since there is <defn>event delegation</defn>, when any one of the list
        elements are clicked, that event <defn>bubbles</defn> up to some
        parent container where it is handled by an <defn>event handler</defn>.
      </p>
      <p>Benefits:</p>
      <ul>
        <li><p>
          <defn>Cleaner</defn>, more <defn>efficient</defn> because one handler
          on a parent element can handle events evoked for any of its children.
        </p></li>
        <li><p>
          No need to <defn>unbind</defn> handler when elements are removed (and
          otherwise when new elements are introduced).
        </p></li>
      </ul>
      <hr>
      <h3>
        2. Explain how <code>this</code> works in JavaScript.
      </h3>
      <p>
        Put simply: the value of <code>this</code> is determined by which
        function calls it (the <defn>call site</defn>), and where the function
        is called.
      </p>
      <p>The rules:</p>
      <ol>
        <li>
          <p>
            If the function containing <code>this</code> is called with the
            <code>new</code> keyword, the <code>this</code> inside the function
            references a new object.
          </p>
          <pre class="language-javascript"><code>function Example() &#123;
  console.log(this);
  this.value = 10;
  console.log(this);
&#125;
new Example();
// prints &#123;&#125;
// prints &#123; value: 10 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called with
            <code>.apply()</code>, <code>.call()</code> or <code>.bind()</code>,
            then <code>this</code> inside the function references the object
            passed as an argument.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
var obj = &#123; value: 5 &#125;
var boundFn = fn.bind(obj);
boundFn(); // &#123; value: 5 &#125;
fn.call(obj); // &#123; value: 5 &#125;</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>method</defn>, then <code>this</code> inside the function
            refereces the object that the <defn>method</defn> belongs to.
          </p>
          <pre class="language-javascript"><code>var obj = &#123;
  value: 5,
  print: function() &#123;
   console.log(this);
  &#125;
&#125;
obj.print(); // &#123; value:5, print: f &#125; (this is obj)</code></pre>
        </li>
        <li>
          <p>
            If the function containing <code>this</code> is called as a
            <defn>free function invocation</defn> (read: not matching any of
            the first 3 conditions), then <code>this</code> inside the function
            is the <defn>global object</defn>. For a browser, this is
            <code>window</code>.
          </p>
          <pre class="language-javascript"><code>function fn() &#123;
  console.log(this);
&#125;
// if it was called in the browser:
fn(); // Window &#123; stop: f, open: f ... &#125;</code></pre>
        </li>
        <li><p>
          If <defn>multiple</defn> of the above rules apply, the
          <defn>higher</defn> one wins (and sets the definition of
          <code>this</code>).
        </p></li>
        <li>
          <p>
            If function containing <code>this</code> is an <defn>arrow function
            </defn>, then all the above rules are ignored. <code>this</code>
            inside the function is the immediate <defn>scope</defn> outside
            where the function is declared.
          </p>
          <pre class="language-javascript"><code>const obj = &#123;
  value: 'hello',
  fn: () =&gt; console.log(this);
&#125;
obj.fn(); // &#123; value: 'hello', fn: f &#125;</code></pre>
        </li>
      </ol>
      <hr>
      <h3>
        3. Explain how <defn>prototypal inheritance</defn> works.
      </h3>
      <p>
        All JavaScript objects have a <defn>prototype</defn> property, which is
        a reference to another object (which is its <defn>'parent'</defn>).
        When we try to access an object's property, and that property isn't
        defined in the object, then the JavaScript engine goes to that object's
        <defn>prototype</defn>. It looks for the property there, and so on
        (until the property is found).
      </p>
      <p>
        Note that this looks like <defn>classical inheritance</defn>, but
        actually behaves differently. We can say that this is simply
        <defn>behaviour delegation</defn>. Properties/,ethods don't get
        'passed' onto children, rather, the <defn>responsibility</defn> for
        properties/methods that aren't found in children, are 'passed' onto
        their parent (<defn>prototype</defn>).
      </p>
      <p>
        In <defn>classical inheritance</defn>, we do have properties/methods
        passed onto children in <defn>compile time</defn>. The <defn>
        inheritance chain</defn> of a class instance (consisting of inherited
        properties/methods) is <defn>flattened</defn> into the instance class.
        (in combination with lookup tables for super functions).
      </p>
      <hr>
      <h3>
        4. <defn>AMD</defn> vs <defn>CommonJS</defn>?
      </h3>
      <p>
        These are both ways to implement a <defn>module system</defn>, which was
        not a feature native in <defn>JavaScript</defn> until
        <defn>ES6/2015</defn>.
      </p>
      <p>
        <defn>CommonJS</defn>: synchronous, and designed for server-side
        development. Syntax is simpler and is closer to
        <defn>Node</defn>. There is less overhead caused by
        <defn>context-switching</defn> between client and server-side JS
        development.
      </p>
      <p>
        <defn>AMD</defn>: a.k.a <defn>Asynchronous Module Definition</defn>
        (read: asynchronous), more intended for browsers. Syntax is much more
        verbose, and often unnecessary because JavaScript files are usually
        bundled, thus not benefiting from asynchronous loading.
      </p>
      <hr>
      <h3>
        5. Explain why the following won't work as an <defn>IIFE</defn>:
        <code class="language-javascript">function()&#123;&#125;();</code>.
        What needs to be changed to properly make it an <defn>IIFE</defn>?
      </h3>
      <p>
        <defn>IIFE</defn>: <defn>Immediately Invoked Function
        Expressions</defn>.
      </p>
      <p>
        This won't work because the parser reads
        <code class="language-javascript">function()&#123;&#125;</code>, and
        then <code class="language-javascript">();</code>. In other words,
        it sees a <defn>function declaration</defn>, and then
        <code class="language-javascript">();</code> which is an attempt to
        call a function... but there is no function! Statements that start
        with <code>function</code> are intepreted as <defn>function
        declarations</defn>.
      </p>
      <p>How to solve</p>
      <ul>
        <li><p>
          Wrap <code class="language-javascript">function()&#123;&#125;</code>
          in <code>()</code> brackets to that the parse reads it as a
          <defn>function expression</defn> instead of a <defn>function
          declaration</defn>. Then <code class="language-javascript">
          (function()&#123;&#125;)();</code> calls it immediately.
        </p></li>
        <li><p>
          The other option is wrapping the entire declaration and call in
          brackets: <code class="language-javascript">
          (function()&#123;&#125;);</code>, which achieves the same effect.
        </p></li>
      </ul>
      <hr>
      <h3>
        6. What's the difference between a variable that is <code>null</code>,
        <code>undefined</code>, or <defn>undeclared</defn>? How would you
        go about checking for any of these states?
      </h3>
      <p>
        <defn>Undeclared variables</defn>: are created when assigning a value
        to a variable that has not been previously created with
        <code>var</code>, <code>let</code>, or <code>const</code> (read:
        <defn>undeclared</defn>). They become <defn>global variables</defn>
        (not good!), and in <defn>strict mode</defn>, a <code>ReferenceError
        </code> is thrown.
      </p>
      <p>
        <code>undefined</code><defn> variables</defn>: are variables that have been
        <defn>declared</defn> (using <code>var</code>, <code>let</code>, or
        <code>const</code>) but have not been explicity <defn>assigned</defn>
        a value. They have a value of <code>undefined</code> until then.
      </p>
      <p>Check for <code>undefined</code><defn> variables</defn> by using:</p>
      <ul>
        <li><p>
          Strict equality: <code class="language-javascript">foo === undefined
          </code>. Note: using <code>==</code> will return true for
          <code class="language-javascript">foo = undefined</code>, but also for
          <code class="language-javascript">foo = null</code>.
        </p></li>
        <li><p>
          Using <code>typeof</code>: <code class="language-javascript">typeof
          foo === 'undefined'</code>.
        </p></li>
      </ul>
      <p>
         <code>null</code><defn> variables</defn>: are variables that have been
         explicitly assigned <code>null</code>. It represents no value. It is
         not <code>undefined</code>, because it is technicall defined... with
         no value.
      </p>
      <p>Check for <code>null</code><defn> variables</defn> by using:</p>
      <ul>
        <li><p>
          Strict equality: <code class="language-javascript">foo === null
          </code>.
        </p></li>
        <li><p>
          Using <code>typeof</code>: <code class="language-javascript">typeof
          foo === 'null'</code>.
        </p></li>
      </ul>
      <p>
        What is good practice? Don't leave variables <defn>undeclared</defn>
        or <code>undefined</code>... When declaring a variable with no value in
        mind, set it to <code>null</code>!
      </p>
    </div>
  </div>
</div>
