<div class='blog'>
  <div class="row">
    <div class="col-12">
      <h3>1. What is <defn>CSS selector specificity</defn> and how does
        it work? </h3>
      <p>
        Specificity is a property of each CSS rule that has matched a
        particular element. For this, we assume that the browser knows which
        CSS rules match some particular element. The specificity for these
        matched rules are determined by four comma-separated values:
        <defn>(a, b, c, d)</defn>.
      </p>
      <ul>
        <li>
          <p>
            <defn>a: </defn>
            1 if the rule is an inline style, 0 otherwise.
            <br>
            <code class="language-html">&lt;h1 style="color: #fff"&gt;</code>
            would get a score of <defn>a = 1</defn>.
          </p>
        </li>
        <li>
          <p>
            <defn>b: </defn>
            number of ID selectors.
            <br>
            <loc>#card #small</loc> has two id selectors, getting a score
            of <defn>b = 2</defn>.
          </p>
        </li>
        <li>
          <p>
            <defn>c: </defn>
            number of classes, attributes, and pseudo-class selectors.
            <br>
            <loc>.select-container .selector input[type="text"]</loc> has two
            class selectors <loc>.select-container</loc> and <loc>.selector</loc>,
            and one attribute selector <loc>[type="text"]</loc>, getting a score
            of <defn>c = 3</defn>.
          </p>
        </li>
        <li>
          <p>
            <defn>d: </defn>
            number of tags, and pseudo-element selectors.
            <br>
            <loc>label:before</loc> has one element <loc>label</loc> and one
            pseudo-element selector <loc>:before</loc> , getting a score of
            <defn>d = 2</defn>.
          </p>
        </li>
      </ul>
      <p>
        The resulting specificity for each rule is matched column by column.
        We go from <defn>a</defn> to <defn>d</defn>, and compare which rules
        have the highest value. So, all rules with <defn>a = 1</defn>, override
        all rules with <defn>a = 0 </defn>no matter what each of them get for
        <defn>b</defn>, <defn>c</defn>, or <defn>d</defn>.
      </p>
      <hr>
      <h3>
        What's the difference between <defn>"resetting"</defn> and
        <defn>"normalizing"</defn> CSS? Which would you choose, and why?
      </h3>
      <p>
        <defn>Resetting: </defn> gets completely rid of the default browser
        styling of elements. This means that you have to re-declare all rules
        from scratch, even the basic ones!
      </p>
      <p>
        <defn>Normalizing: </defn> doesn't get rid of all default styling.
        Rather, it keeps the 'useful' ones. It also corrects some browser bugs.
      </p>
      <p>
        Which to choose? Use reset if we are designing an unconventional
        site, and normalize otherwise.
      </p>
      <hr>
      <h3>
        Describe <defn>floats</defn> and how they work.
      </h3>
      <p>
        <defn>Float</defn> is a css positioning property. <loc>float</loc> can
        take a value of <loc>left</loc> or <loc>right</loc> which stick the
        elements in those directions respectively. Floated elements remain in
        the <defn>flow </defn> of a page -- meaning they will affect the
        positioning of other elements. <loc>float</loc> can also takes values
        <loc>none</loc> and <loc>inherit</loc> , which are self explanatory.
      </p>
      <p>
        If a floated element A is inline beside a floated element B, you can
        use <loc>clear</loc> on any one of those elements to move it to the
        next line.
      </p>
      <p>
        If some elements contain only floated elements, then it will have 0
        height. We can fix this in a couple of ways:
      </p>
      <ul>
        <li>
          <p>Set the parent's content to <loc>overflow: auto</loc></p>
        </li>
        <li>
          <p>Add an element with <loc>clear: both</loc> before the close of the
            container
          </p>
        </li>
      </ul>
      <hr>
      <h3>
        Describe <defn>z-index</defn>, and how a <defn>stacking context</defn>
        is formed.
      </h3>
      <p>
        <loc>z-index</loc> controls the vertical stacking order of elements.
        They only affect elements that don't have <loc>position: static</loc>
        (which is the default position property).
      </p>
      <p>
        When there is no <loc>z-index</loc> specified, then elements are
        stacked in the order that they appear in the DOM (top-level at the
        bottom). Elements that don't have <loc>position: static</loc> always
        appear on top over those that do.
      </p>
      <p>
        A <defn>stacking context</defn> is a parent element containing more
        elements. The <loc>z-index</loc> of a <defn>stacking context</defn>'s
        child elements are only relevent within their parent element (read:
        they don't affect other elements outside the
        <defn>stacking context</defn>.)
      </p>
      <p>
        There are many ways to trigger a <defn>stacking context</defn>, such
        as having <loc>opacity</loc> less than 1, and <loc>filter</loc> that is
        not <loc>none</loc>
      </p>
      <hr>
      <h3>Describe <defn>Block Formatting Context</defn> and how it works.</h3>
      <p>
        A <defn>Block Formatting Context</defn> is caused by:
      </p>
      <ul>
        <li><p>
          <loc>float</loc> value other than <loc>none</loc>.
        </p></li>
        <li><p>
          <loc>position</loc> value that isn't <loc>static</loc> or
            <loc>none</loc>.
        </p></li>
        <li><p>
          <loc>display</loc> value of <loc>table-cell</loc>,
          <loc>table-caption</loc>, <loc>inline-block</loc>, or
          <loc>inline-flex</loc>.
        </p></li>
        <li><p>
          <loc>overflow</loc> value that isn't <loc>visible</loc>.
        </p></li>
      </ul>
      <p>
        Each box element contained inside a <defn>BFC</defn> has its left side
        touching the left edge of the <defn>BFC.</defn>
      </p>
      <p>
        Also, vertical margins on stacking elements don't take the sum of the
        margins. Instead, they take only the largest of the two, combining
        them to form a single margin.
      </p>
      <hr>
      <h3>
        What are the various <defn>clearing</defn> techniques and which is
        appropriate for each context?
      </h3>
      <p>
        This is about floated elements. You can clear them by using:
      </p>
      <ul>
        <li><p>
            An empty <loc>div</loc> with <loc>clear: both</loc>.
        </p></li>
        <li><p>
            The <loc>clearfix</loc> class.
        </p></li>
        <li><p>
            <loc>overflow: auto</loc> or <loc>overflow: hidden</loc>, which
            establishes a BFC.
        </p></li>
      </ul>
      <hr>
      <h3>
        How would you approach fixing browser-specific styling issues?
      </h3>
      <p>You can fix these issues by using:</p>
      <ul>
        <li><p>
          A separate stylesheet that loads only for a specific browser.
        </p></li>
        <li><p>
          Libraries that do this for you, such as <defn>Bootstrap</defn>
        </p></li>
        <li><p>
          <defn>Reset CSS</defn> or <defn>Normalize CSS</defn>
        </p></li>
      </ul>
      <hr>
      <h3>
        How do you serve your pages for <defn>feature-constrained</defn>
        browsers? What techniques should you use?
      </h3>
      <p>Some ways:</p>
      <ul>
        <li><p>
          <defn>Graceful degradation: </defn> build the web-app for modern
          browsers first, but ensure that it is functional for older browsers.
        </p></li>
        <li><p>
          <defn>Progressive enhancement: </defn> implement the web-app with the
          base-level of user experience, then add more functionality for modern
          browsers (that can support features).
        </p></li>
      </ul>
      <hr>
      <h3>
        What are the different ways to <defn>visually hide content</defn> (and
        make it available only for screen readers)?
      </h3>
      <p>Some ways:</p>
      <ul>
        <li><p>
          <loc>visibility: hidden</loc>, where element will still take up space.
        </p></li>
        <li><p>
          <loc>width: 0, height: 0</loc>, where element won't take up space.
        </p></li>
        <li><p>
          <loc>position: absolute, left: -9999px</loc>, where element is taken
          off the flow of the page, and positioned off-screen.
        </p></li>
        <li><p>
          <defn>WAI-ARIA</defn>, using <loc>aria-hidden: true</loc>.
        </p></li>
      </ul>
      <hr>
      <h3>
        Have you ever used a <defn>grid system</defn>? If so, which do you
        prefer?
      </h3>
      <p>
        There are <defn>float</defn>, <defn>flex</defn>, and <defn>grid</defn>
        systems. <defn>Float</defn> has the most browser support, although
        <defn>flex</defn> and <defn>grid</defn> are preferred nowadays.
      </p>
      <hr>
      <h3>
        Have you used or implemented <defn>media queries</defn> or mobile
        specific layouts/CSS?
      </h3>
      <p>
        Yes: collapsing navigation into a hamburger menu (with popup) for
        mobile devices. This layout is applied when the screen width is
        small enough.
      </p>
      <hr>
      <h3>
        Are you familiar with styling <defn>SVG</defn>?
      </h3>
      <p>
        Yes: attributes can be used on inline styles in the HTML. Like so:
        <loc>&lt;rect x="10" y="10" width="100" height="100" fill="purple"&gt;</loc>
      </p>
      <p>
        Styling can also be applied through JavaScript, like so:
        <loc>("rect").attr("x", 10).attr("y", 10).attr("width", 100)
        .attr("height", 100).attr("fill", "purple")</loc>
      </p>
      <hr>
      <h3>
        Can you give an example of an <defn>@media</defn> property other
        than <defn>screen</defn>?
      </h3>
      <p>
        There are four types:
      </p>
      <ul>
        <li><p>
          <defn>all: </defn> all media type devices.
        </p></li>
        <li><p>
          <defn>print: </defn> printers.
        </p></li>
        <li><p>
          <defn>speech: </defn> screen-readers that "read" a page out loud.
        </p></li>
        <li><p>
          <defn>screen: </defn> device screens.
        </p></li>
      </ul>
      <p>
        When using these <defn>@media</defn> properties, you specify a style
        just for those specific media outputs.
      </p>
      <hr>
      <h3>
        What are some of "gotchas" for writing efficient CSS?
      </h3>
      <p>
        Browsers <defn>match selectors</defn> from the <defn>right-most
        selector</defn>, then proceeds leftwards. In a selector such as
        <loc>.card .title span</loc>, the browser tries to match <loc>span</loc>
        first, and then filters all <loc>span</loc> elements by
        <loc>.title</loc>, and so on. This is not good because <loc>span</loc>
        matches a lot of elements! We try to avoid having key selectors that
        are <defn>tag</defn> or <defn>universal</defn>.
      </p>
      <p>
        We must also be aware which CSS properties trigger <defn>reflow</defn>,
        <defn>repaint</defn>, and <defn>compositing</defn>. We want to only
        apply proprties that trigger <defn>compositing</defn> (and avoid ones
        that trigger <defn>repaint</defn> and <defn>reflow</defn>, because
        those require the browser to do more work).
      </p>
    </div>
  </div>
</div>
